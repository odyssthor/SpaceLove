<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Love: San Valentín ❤️</title>
    
    <!-- Meta tags para previsualización -->
    <meta property="og:title" content="Space Love: San Valentín ❤️">
    <meta property="og:image" content="https://space-love.netlify.app/assets/icon.webp">
    <meta property="og:url" content="https://space-love.netlify.app/">
    <meta property="og:type" content="website">



    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Indie+Flower&display=swap" rel="stylesheet">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>❤️</text></svg>">

    <link rel="preload" href="https://www.dl.dropboxusercontent.com/scl/fi/7lgy702ivisechb0b3y34/start.webp?rlkey=do0pnswi7udmbqu7adv0kmmvq&st=c1cwt0xm" as="image" type="image/webp">

   



    <style>
        :root {
            --neon-pink-fill: #ff69b4;
            --neon-pink-stroke: #ff94ef;
            --neon-purple-fill: #bb8eff;
            --neon-purple-stroke: #da90ff;
            --neon-blue-fill: #ff98fd;
            --neon-blue-stroke: #fc84d6;
            --neon-green-fill: #f89aff;
            --neon-green-stroke: #f6a4ff;
            --neon-yellow-fill: #d989f9;
            --neon-yellow-stroke: #d99efb;
            --neon-orange-fill: #fc9fff;
            --neon-orange-stroke: #ffccfd;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Indie Flower', cursive;
            cursor: grab;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        body:active {
            cursor: grabbing;
        }
        
        canvas {
            display: block;
        }

        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 9999;
            /* Esto asegura que el contenido no se desborde en móviles */
            padding: 20px; 

            transition: opacity 0.8s ease-in-out; 
            opacity: 1; /* Aseguramos que empiece visible */
            pointer-events: auto; /* Permite clicks */

            will-change: opacity; 


        }
        .hidden {
            opacity: 0 !important;
            pointer-events: none; /* Evita clicks mientras desaparece */
        }

        @keyframes heartbeat {
            0%, 100% {
                transform: scale(1);
                filter: drop-shadow(0 0 5px rgba(255, 20, 147, 0.5)) brightness(1);
            }
            50% {
                transform: scale(1.18); /* Más movimiento */
                /* Sombra más amplia y saturada */
                filter: drop-shadow(0 0 25px rgba(255, 20, 147, 1)) brightness(1.3);
            }
        }

        /* Texto acompañando la intensidad */
        @keyframes textPulse {
            0%, 100% {
                transform: scale(1);
                text-shadow: 0 0 10px #ff1493;
                color: #ffb7d5;
            }
            50% {
                transform: scale(1.1); /* Un poco más grande también */
                text-shadow: 0 0 8px #fff, 0 0 25px #ff1493; /* Resplandor más amplio */
                color: #fff;
            }
        }

        #start-button {
            width: 180px; 
            max-width: 50vw;
            height: auto;
            background: transparent;
            border: none;
            cursor: pointer;
            margin-bottom: 30px;
            
            will-change: transform, filter; 
            animation: heartbeat 1.5s infinite ease-in-out;
            
            display: block;
            object-fit: contain;
            -webkit-appearance: none; 
            appearance: none;
        }

        #start-text {
            font-size: 2em;
            font-family: 'Indie Flower', cursive;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-align: center;
            width: 100%;
            padding: 0 10px;
            
            will-change: transform, text-shadow;
            animation: textPulse 1.5s infinite ease-in-out;
        }


    </style>
</head>
<body>
    <div id="start-screen">
        <img src="https://www.dl.dropboxusercontent.com/scl/fi/7lgy702ivisechb0b3y34/start.webp?rlkey=do0pnswi7udmbqu7adv0kmmvq&st=c1cwt0xm" id="start-button" alt="Start">
        <div id="start-text">Toca para iniciar...</div>
    </div>

    <audio id="background-music" loop>
        <source src="https://www.dl.dropboxusercontent.com/scl/fi/ozf5r93r209ldo6601ch3/sound.mp3?rlkey=tci8wrtc93yx0e3y42anqxqov&st=ur2ira95" type="audio/mpeg">
        Tu navegador no soporta el elemento de audio.
    </audio>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        class LoveAnimation3D {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                
                this.loveTexts = [];
                this.loveImages = [];
                this.stars = [];
                
                this.config = {
                    textCount: 100,
                    imageCount: 50,
                    heartCount: 100,
                    starCount: 5000,
                    baseSpeed: 0.1,
                    autoRotSpeed: 0.0, 
                    heartRotSpeed: 0.02,
                    textWidth: 32,
                    textHeight: 7,
                    imageSize: 7, 
                    heartScale: 0.15,
                    cubeSize: 80
                };
                
                this.userInteracting = false;
                
                this.loveQuotes = [
                    "Feliz San Valentín", "14-02-2026",
                    "Te amo mucho", "Sé mi Valentín", "Amor Infinito",
                    "Juntos por siempre", "Eres mi todo", 
                    "Mi Amor", "Te adoro", "Forever",
                    "Love You", "Mi Vida", "Siempre Tú"
                ];
                
                // NOTA: Asegúrate de que estas imágenes existen en tu carpeta 'assets'
                this.imageUrls = [
                    'https://www.dl.dropboxusercontent.com/scl/fi/8kb5o1unb8o6sd7lcqoo6/img1.webp?rlkey=fh7guj55mid4sd0xhfptosmbr&st=0k0tu9so',
                    'https://www.dl.dropboxusercontent.com/scl/fi/tb93y7763w9fnzexk3d74/img2.webp?rlkey=4ikj0qmz6pxfvtcyoqnodv72i&st=2vrvzckd',
                    'https://www.dl.dropboxusercontent.com/scl/fi/wz3ctzztcpkxkm76y4pjl/img3.webp?rlkey=l2pfa2nc372w8uhouzw08dgw0&st=jscfz3xa',
                    'https://www.dl.dropboxusercontent.com/scl/fi/7ppazik58y7wdxf6tyevb/img4.webp?rlkey=dposvo2uj0k1ibloa7xq67z2x&st=nwukvscp',
                    'https://www.dl.dropboxusercontent.com/scl/fi/3rxd20iwwpcu5ix0xitxc/img5.webp?rlkey=vmfki4n3tx3froxd7eawble36&st=oxs420fv',
                    'https://www.dl.dropboxusercontent.com/scl/fi/s4if8h2ao0nzl73oi9owk/img6.webp?rlkey=intzvwd09umwzh4kw5r70jjzh&st=dnqa1wdz',
                    'https://www.dl.dropboxusercontent.com/scl/fi/vue7swq9sazxulpk3f0z3/img7.webp?rlkey=r8knw80ultnl7k3wf6gtflk3z&st=wpp57fwx'
                ];
                
                this.neonColors = [
                    { fill: '#ff69b4', stroke: '#ff94ef', shadow: '#ff69b4' },
                    { fill: '#bb8eff', stroke: '#da90ff', shadow: '#bb8eff' },
                    { fill: '#ff98fd', stroke: '#fc84d6', shadow: '#ff98fd' },
                    { fill: '#f89aff', stroke: '#f6a4ff', shadow: '#f89aff' },
                    { fill: '#d989f9', stroke: '#d99efb', shadow: '#d989f9' },
                    { fill: '#fc9fff', stroke: '#ffccfd', shadow: '#fc9fff' }
                ];
                
                this.init();
            }
            
            init() {
                this.createScene();
                this.createCamera();
                this.createRenderer();
                this.createLights();
                this.createCubeFrame();
                this.createLoveElements();
                this.createStars();
                this.createControls();
                this.setupEventListeners();
                this.animate();
            }
            
            createScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x000000, 80, 250);
            }
            
            createCamera() {
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 0, 40);
            }
            
            createRenderer() {
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000000);

                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));


                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(this.renderer.domElement);
            }
            
            createLights() {
                this.scene.add(new THREE.AmbientLight(0x404040, 0.4));
                const directionalLight = new THREE.DirectionalLight(0xff69b4, 1.0);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);
                this.scene.add(new THREE.DirectionalLight(0x9932cc, 0.6).position.set(-10, -10, -5));
            }
            
            createCubeFrame() {
                this.bounds = {
                    x: [-this.config.cubeSize/2, this.config.cubeSize/2],
                    y: [-this.config.cubeSize/2, this.config.cubeSize/2],
                    z: [-this.config.cubeSize/2, this.config.cubeSize/2]
                };
            }
            
            createTextTexture(text) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 1536;
                canvas.height = 384;
                const color = this.neonColors[Math.floor(Math.random() * this.neonColors.length)];
                
                context.font = '96px "Indie Flower", cursive';
                context.fillStyle = color.fill;
                context.strokeStyle = color.stroke;
                context.lineWidth = 3;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.shadowColor = color.shadow;
                context.shadowBlur = 25;
                
                context.strokeText(text, canvas.width / 2, canvas.height / 2);
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                
                return new THREE.CanvasTexture(canvas);
            }
            
            createRoundedImageTexture(texture) {
                const canvas = document.createElement('canvas');
                const img = texture.image;
                const maxSize = 512;
                let width, height;

                if (img.width > img.height) {
                    width = maxSize;
                    height = (img.height / img.width) * maxSize;
                } else {
                    height = maxSize;
                    width = (img.width / img.height) * maxSize;
                }
                
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                const radius = Math.min(width, height) * 0.1;
                
                ctx.beginPath();
                ctx.moveTo(radius, 0);
                ctx.lineTo(width - radius, 0);
                ctx.quadraticCurveTo(width, 0, width, radius);
                ctx.lineTo(width, height - radius);
                ctx.quadraticCurveTo(width, height, width - radius, height);
                ctx.lineTo(radius, height);
                ctx.quadraticCurveTo(0, height, 0, height - radius);
                ctx.lineTo(0, radius);
                ctx.quadraticCurveTo(0, 0, radius, 0);
                ctx.closePath();
                ctx.clip();
                ctx.drawImage(img, 0, 0, width, height);
                
                return new THREE.CanvasTexture(canvas);
            }
            
            createLoveElements() {
                // Textos
                for (let i = 0; i < this.config.textCount; i++) {
                    const quote = this.loveQuotes[Math.floor(Math.random() * this.loveQuotes.length)];
                    const texture = this.createTextTexture(quote);
                    const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, alphaTest: 0.1 });
                    const geometry = new THREE.PlaneGeometry(this.config.textWidth, this.config.textHeight);
                    const textMesh = new THREE.Mesh(geometry, material);
                    
                    this.resetElementPosition(textMesh);
                    textMesh.userData = { speed: Math.random() * this.config.baseSpeed + this.config.baseSpeed/2, isText: true };
                    this.scene.add(textMesh);
                    this.loveTexts.push(textMesh);
                }
                
                // Imágenes
                // CORRECCIÓN: Agregado setCrossOrigin para evitar problemas de carga
                const loader = new THREE.TextureLoader();
                loader.setCrossOrigin('anonymous');
                
                for (let i = 0; i < this.config.imageCount; i++) {
                    const imageUrl = this.imageUrls[i % this.imageUrls.length];
                    loader.load(imageUrl, (texture) => {
                        const originalWidth = texture.image.width;
                        const originalHeight = texture.image.height;
                        const aspectRatio = originalWidth / originalHeight;

                        let planeWidth = this.config.imageSize;
                        let planeHeight = this.config.imageSize;

                        if (aspectRatio > 1) { 
                            planeHeight = this.config.imageSize / aspectRatio;
                        } else { 
                            planeWidth = this.config.imageSize * aspectRatio;
                        }

                        const roundedTexture = this.createRoundedImageTexture(texture);
                        const material = new THREE.MeshBasicMaterial({ map: roundedTexture, transparent: true, alphaTest: 0.1 });
                        
                        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                        const imageMesh = new THREE.Mesh(geometry, material);
                        
                        this.resetElementPosition(imageMesh);
                        imageMesh.userData = { 
                            speed: Math.random() * this.config.baseSpeed + this.config.baseSpeed/2,
                            rotationSpeed: Math.random() * this.config.heartRotSpeed - this.config.heartRotSpeed/2,
                            isText: false,
                            isImage: true
                        };
                        this.scene.add(imageMesh);
                        this.loveImages.push(imageMesh);
                    }, undefined, (error) => {
                        // Si falla la carga (ej. ruta incorrecta), crea un corazón en su lugar
                        console.warn("Error cargando imagen, usando corazón:", error);
                        this.createHeartAsFallback();
                    });
                }
                
                // Corazones 3D
                for (let i = 0; i < this.config.heartCount; i++) this.createHeartAsFallback();
            }
            
            createHeartAsFallback() {
                const heartGeometry = this.createHeartGeometry();
                const heartMaterial = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color().setHSL(Math.random() * 0.15 + 0.85, 1, Math.random() * 0.4 + 0.7),
                    emissive: new THREE.Color().setHSL(Math.random() * 0.15 + 0.85, 0.8, Math.random() * 0.15 + 0.25),
                    emissiveIntensity: 0.4,
                    transparent: true,
                    opacity: 0.95
                });
                const heart = new THREE.Mesh(heartGeometry, heartMaterial);
                this.resetElementPosition(heart);
                heart.userData = { 
                    speed: Math.random() * this.config.baseSpeed + this.config.baseSpeed/2,
                    rotationSpeed: Math.random() * this.config.heartRotSpeed - this.config.heartRotSpeed/2,
                    isText: false, isImage: false
                };
                this.scene.add(heart);
                this.loveImages.push(heart);
            }
            
            createHeartGeometry() {
                const shape = new THREE.Shape();
                const x = 0, y = 0;
                shape.moveTo(x + 5, y + 5);
                shape.bezierCurveTo(x + 5, y + 5, x + 4, y, x, y);
                shape.bezierCurveTo(x - 6, y, x - 6, y + 3.5,x - 6, y + 3.5);
                shape.bezierCurveTo(x - 6, y + 5.5, x - 4, y + 7.7, x + 5, y + 15);
                shape.bezierCurveTo(x + 14, y + 7.7, x + 16, y + 5.5, x + 16, y + 3.5);
                shape.bezierCurveTo(x + 16, y + 3.5, x + 16, y, x + 10, y);
                shape.bezierCurveTo(x + 7, y, x + 5, y + 5, x + 5, y + 5);
                const extrudeSettings = { depth: 3, bevelEnabled: true, bevelSegments: 2, steps: 1, bevelSize: 0.8, bevelThickness: 0.8 };
                const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                geometry.scale(this.config.heartScale, this.config.heartScale, this.config.heartScale);
                return geometry;
            }
            
            createStars() {
                const starGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                for (let i = 0; i < this.config.starCount; i++) {
                    const starMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff, 
                        transparent: true,
                        opacity: Math.random() * 0.8 + 0.2
                    });
                    
                    const star = new THREE.Mesh(starGeometry, starMaterial);
                    star.position.set(
                        (Math.random() - 0.5) * this.config.cubeSize,
                        (Math.random() - 0.5) * this.config.cubeSize,
                        (Math.random() - 0.5) * this.config.cubeSize
                    );
                    star.userData = {
                        originalPosition: star.position.clone(),
                        floatSpeed: Math.random() * 0.02 + 0.01,
                        floatRange: Math.random() * 2 + 1,
                        time: Math.random() * Math.PI * 2
                    };
                    this.scene.add(star);
                    this.stars.push(star);
                }
            }
            
            resetElementPosition(element) {
                element.position.set(
                    (Math.random() - 0.5) * this.config.cubeSize,
                    (Math.random() - 0.5) * this.config.cubeSize,
                    (Math.random() - 0.5) * this.config.cubeSize
                );
                if (!element.userData.isText && !element.userData.isImage) {
                    element.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                } else {
                    element.rotation.set(0, 0, 0);
                }
            }
            
            createControls() {
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.screenSpacePanning = false;
                this.controls.minDistance = 0;
                this.controls.maxDistance = 150;
                this.controls.maxPolarAngle = Math.PI;
                this.controls.addEventListener('start', () => { this.userInteracting = true; });
                this.controls.addEventListener('end', () => { this.userInteracting = false; });
            }
            
            setupEventListeners() {
                window.addEventListener('resize', () => this.onWindowResize(), false);
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // autoRotateSpeed ahora es 0.0, por lo que no girará automáticamente
                this.controls.autoRotate = !this.userInteracting;
                this.controls.autoRotateSpeed = this.config.autoRotSpeed;
                
                // Caída vertical pura (eje Y) para textos
                this.loveTexts.forEach(text => {
                    text.position.y -= text.userData.speed;
                    text.lookAt(this.camera.position);
                    if (text.position.y < this.bounds.y[0]) text.position.y = this.bounds.y[1];
                });
                
                // Caída vertical pura (eje Y) para imágenes y corazones
                this.loveImages.forEach(image => {
                    image.position.y -= image.userData.speed;
                    if (image.userData.isImage) {
                        image.lookAt(this.camera.position);
                    } else {
                        // Rotación interna del corazón (sobre sí mismo)
                        image.rotation.y += image.userData.rotationSpeed;
                        image.rotation.x += image.userData.rotationSpeed * 0.5;
                    }
                    if (image.position.y < this.bounds.y[0]) image.position.y = this.bounds.y[1];
                });
                
                this.stars.forEach(star => {
                    star.userData.time += star.userData.floatSpeed;
                    star.position.copy(star.userData.originalPosition);
                    star.position.y += Math.sin(star.userData.time) * star.userData.floatRange;
                    star.position.x += Math.cos(star.userData.time * 0.7) * star.userData.floatRange * 0.5;
                    star.material.opacity = 0.3 + Math.sin(star.userData.time * 2) * 0.3;
                });
                
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        let loveAnimation;
        
        window.addEventListener('load', () => {
            loveAnimation = new LoveAnimation3D();
        });

        document.getElementById('start-button').addEventListener('click', () => {
            const startScreen = document.getElementById('start-screen');
            const backgroundMusic = document.getElementById('background-music');
            const startButton = document.getElementById('start-button');
            const startText = document.getElementById('start-text');

            // 1. Inmediatamente intentamos reproducir el audio
            backgroundMusic.play().catch(error => { console.error("Autoplay failed:", error); });
            
            // 2. Truco visual: Desactivamos la animación de latido del botón inmediatamente
            // para liberar recursos gráficos antes de la transición
            startButton.style.animation = 'none';
            startText.style.animation = 'none';

            // 3. MICRO-RETRASO: Esperamos 100ms para iniciar el desvanecimiento.
            // Esto permite que el audio cargue y el hilo principal se libere
            // antes de pedirle a la GPU que haga el fade.
            setTimeout(() => {
                startScreen.classList.add('hidden');
            }, 100);
            
            // 4. Eliminamos el elemento del DOM al terminar la transición (0.8s = 800ms)
            // Damos un pequeño margen extra (900ms)
            setTimeout(() => {
                startScreen.style.display = 'none';
            }, 900);
        });
    </script>

</body>
</html>